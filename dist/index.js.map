{"version":3,"sources":["../src/core/app.ts","../src/core/response.ts","../src/core/middleware.ts","../src/auth/index.ts","../src/database/index.ts","../src/cache/index.ts","../src/storage/index.ts","../src/queue/index.ts","../src/logging/index.ts","../src/security/index.ts","../src/errors/index.ts","../src/security/rate-limiter/memory-store.ts","../src/security/rate-limiter/kv-store.ts","../src/security/rate-limiter/index.ts","../src/plugins/registry.ts","../src/plugins/index.ts"],"names":["applyCorsHeaders","response","corsHeaders","newHeaders","key","value","createApp","options","middlewares","routes","middleware","path","handler","request","env","executionContext","url","context","result","error","jsonResponse","data","status","errorResponse","message","successResponse","redirectResponse","location","corsMiddleware","origin","methods","allowHeaders","credentials","headers","jsonMiddleware","body","securityHeadersMiddleware","base64urlEncode","str","base64urlDecode","padding","base64","createAuth","sessionDuration","user","header","now","payload","encodedHeader","encodedPayload","encoder","signature","encodedSignature","token","authHeader","signatureBytes","c","sessionId","expiresAt","row","validateIdentifier","name","createDatabase","db","sql","params","table","keys","values","placeholders","whereClause","whereParams","setClause","queries","statements","q","createCache","kv","defaultTTL","ttlSeconds","ttl","results","compute","cached","k","createStorage","bucket","metadata","object","obj","createQueue","queueBinding","messages","batch","createQueueConsumer","processor","_env","_ctx","LOG_LEVELS","createLogger","minLevel","service","environment","shouldLog","level","formatLog","output","entry","additionalContext","nestedContext","rateLimit","store","windowMs","record","validateRequest","schema","errors","field","rules","CloudflareKitError","code","statusCode","isOperational","HttpError","_HttpError","retryAfter","RateLimitError","ValidationError","_ValidationError","zodError","issue","AuthError","_AuthError","limit","remaining","resetTime","DatabaseError","query","originalError","CacheError","ConfigError","PluginError","pluginName","isCloudflareKitError","isOperationalError","handleError","isDev","createMemoryRateLimitStore","timers","existingTimer","timer","createKVRateLimitStore","config","prefix","getKey","rateData","fullKey","current","createRateLimiter","maxRequests","windowSeconds","keyGenerator","defaultKeyGenerator","skip","getRateLimitData","createNewWindow","allowed","incremented","PluginRegistry","plugin","dep","event","otherEntry","sorted","a","b","priorityDiff","args","handlers","globalRegistry","definePlugin","createPlugin","factory","composePlugins","version","plugins","p"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Core Application Module\n *\n * Provides createApp() - the main entry point for building\n * Cloudflare Worker applications with middleware support.\n */\n\nimport type { Middleware, RequestContext, AppOptions, Handler } from \"./types\";\n\n/**\n * Apply CORS headers to a response if they exist\n */\nfunction applyCorsHeaders(response: Response, corsHeaders: Record<string, string> | undefined): Response {\n    if (!corsHeaders) {\n        return response;\n    }\n\n    // Clone the response with new headers\n    const newHeaders = new Headers(response.headers);\n    for (const [key, value] of Object.entries(corsHeaders)) {\n        newHeaders.set(key, value);\n    }\n\n    return new Response(response.body, {\n        status: response.status,\n        statusText: response.statusText,\n        headers: newHeaders,\n    });\n}\n\n/**\n * Create a new Cloudflare Worker application\n *\n * @example\n * ```typescript\n * const app = createApp({\n *   database: createDatabase({ binding: env.DB }),\n *   cache: createCache({ binding: env.CACHE })\n * });\n *\n * app.use(loggingMiddleware);\n * app.get('/users', getUsersHandler);\n *\n * export default app;\n * ```\n */\nexport function createApp(options: AppOptions = {}) {\n    const middlewares: Middleware[] = [];\n    const routes = new Map<string, Handler>();\n\n    return {\n        /**\n         * Add middleware to the application\n         */\n        use(middleware: Middleware) {\n            middlewares.push(middleware);\n            return this;\n        },\n\n        /**\n         * Register a GET route\n         */\n        get(path: string, handler: Handler) {\n            routes.set(`GET:${path}`, handler);\n            return this;\n        },\n\n        /**\n         * Register a POST route\n         */\n        post(path: string, handler: Handler) {\n            routes.set(`POST:${path}`, handler);\n            return this;\n        },\n\n        /**\n         * Register a PUT route\n         */\n        put(path: string, handler: Handler) {\n            routes.set(`PUT:${path}`, handler);\n            return this;\n        },\n\n        /**\n         * Register a DELETE route\n         */\n        delete(path: string, handler: Handler) {\n            routes.set(`DELETE:${path}`, handler);\n            return this;\n        },\n\n        /**\n         * Register a PATCH route\n         */\n        patch(path: string, handler: Handler) {\n            routes.set(`PATCH:${path}`, handler);\n            return this;\n        },\n\n        /**\n         * Handle incoming requests (called by Cloudflare Workers)\n         */\n        async fetch(\n            request: Request,\n            env: Record<string, unknown>,\n            executionContext: ExecutionContext,\n        ): Promise<Response> {\n            const url = new URL(request.url);\n            const method = request.method;\n            const key = `${method}:${url.pathname}`;\n\n            const context: RequestContext = {\n                request,\n                url,\n                env,\n                executionContext,\n                state: {},\n                ...options,\n            };\n\n            // Run middlewares\n            for (const middleware of middlewares) {\n                const result = await middleware(context);\n                if (result instanceof Response) {\n                    // Apply CORS headers if they were set by middleware\n                    return applyCorsHeaders(result, context.state.corsHeaders as Record<string, string> | undefined);\n                }\n            }\n\n            // Find and execute handler\n            const handler = routes.get(key);\n            if (handler) {\n                try {\n                    const response = await handler(context);\n                    // Apply CORS headers if they were set by middleware\n                    return applyCorsHeaders(response, context.state.corsHeaders as Record<string, string> | undefined);\n                } catch (error) {\n                    console.error(\"Handler error:\", error);\n                    return new Response(JSON.stringify({ error: \"Internal server error\" }), {\n                        status: 500,\n                        headers: { \"Content-Type\": \"application/json\" },\n                    });\n                }\n            }\n\n            return new Response(\"Not Found\", { status: 404 });\n        },\n    };\n}\n\n// Re-export types\nexport type { Middleware, RequestContext, AppOptions, Handler } from \"./types\";\n","/**\n * Response Helpers\n *\n * Simple utilities for creating common HTTP responses.\n */\n\n/**\n * Create a JSON response\n *\n * @example\n * ```typescript\n * return jsonResponse({ users: [] });\n * return jsonResponse({ user }, 201);\n * ```\n */\nexport function jsonResponse(data: unknown, status: number = 200): Response {\n    return new Response(JSON.stringify(data), {\n        status,\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n    });\n}\n\n/**\n * Create an error response\n *\n * @example\n * ```typescript\n * return errorResponse('User not found', 404);\n * return errorResponse('Invalid input', 400);\n * ```\n */\nexport function errorResponse(message: string, status: number = 500): Response {\n    return jsonResponse({ error: message }, status);\n}\n\n/**\n * Create a success response\n *\n * @example\n * ```typescript\n * return successResponse('User created');\n * ```\n */\nexport function successResponse(message: string, status: number = 200): Response {\n    return jsonResponse({ success: true, message }, status);\n}\n\n/**\n * Create a redirect response\n *\n * @example\n * ```typescript\n * return redirectResponse('/login');\n * return redirectResponse('/dashboard', 301);\n * ```\n */\nexport function redirectResponse(location: string, status: number = 302): Response {\n    return new Response(null, {\n        status,\n        headers: {\n            Location: location,\n        },\n    });\n}\n","/**\n * Middleware System\n *\n * Pre-built middleware for common tasks.\n */\n\nimport type { Middleware, RequestContext } from \"./types\";\nimport { errorResponse } from \"./response\";\n\n/**\n * Add CORS headers to responses\n *\n * @example\n * ```typescript\n * app.use(corsMiddleware());\n * app.use(corsMiddleware({ origin: 'https://example.com' }));\n * ```\n */\nexport function corsMiddleware(\n    options: {\n        origin?: string;\n        methods?: string;\n        allowHeaders?: string;\n        credentials?: boolean;\n    } = {},\n): Middleware {\n    const origin = options.origin || \"*\";\n    const methods = options.methods || \"GET, POST, PUT, DELETE, PATCH, OPTIONS\";\n    const allowHeaders = options.allowHeaders || \"Content-Type, Authorization\";\n    const credentials = options.credentials;\n\n    return async (context: RequestContext): Promise<Response | void> => {\n        if (context.request.method === \"OPTIONS\") {\n            const headers: Record<string, string> = {\n                \"Access-Control-Allow-Origin\": origin,\n                \"Access-Control-Allow-Methods\": methods,\n                \"Access-Control-Allow-Headers\": allowHeaders,\n            };\n            if (credentials) {\n                headers[\"Access-Control-Allow-Credentials\"] = \"true\";\n            }\n            return new Response(null, {\n                status: 204,\n                headers,\n            });\n        }\n\n        // Store CORS headers to be applied by the app\n        context.state.corsHeaders = {\n            \"Access-Control-Allow-Origin\": origin,\n            ...(credentials && { \"Access-Control-Allow-Credentials\": \"true\" }),\n        };\n        return undefined;\n    };\n}\n\n/**\n * Parse JSON request body\n *\n * @example\n * ```typescript\n * app.use(jsonMiddleware());\n * // Now context.state.body contains parsed JSON\n * ```\n */\nexport function jsonMiddleware(): Middleware {\n    return async (context: RequestContext): Promise<Response | void> => {\n        const contentType = context.request.headers.get(\"content-type\");\n\n        if (contentType?.includes(\"application/json\")) {\n            try {\n                const body = await context.request.json();\n                context.state.body = body;\n            } catch {\n                return errorResponse(\"Invalid JSON\", 400);\n            }\n        }\n        return undefined;\n    };\n}\n\n/**\n * Add security headers to all responses\n *\n * @example\n * ```typescript\n * app.use(securityHeadersMiddleware());\n * ```\n */\nexport function securityHeadersMiddleware(): Middleware {\n    return async (): Promise<Response | void> => {\n        // Headers are added by wrapping the final response\n        // This is handled internally by the app\n        return undefined;\n    };\n}\n","/**\n * Authentication Module\n *\n * Provides createAuth() for JWT and session-based authentication.\n */\n\nimport type { D1Database } from \"../database/types\";\n\n/**\n * Encode string to base64url (URL-safe base64)\n */\nfunction base64urlEncode(str: string): string {\n    return btoa(str).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n\n/**\n * Decode base64url string\n */\nfunction base64urlDecode(str: string): string {\n    // Restore padding\n    const padding = \"=\".repeat((4 - (str.length % 4)) % 4);\n    const base64 = str.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n    return atob(base64);\n}\n\nexport interface AuthOptions {\n    jwtSecret: string;\n    sessionDuration?: number; // in seconds, default 7 days\n    database?: D1Database;\n}\n\nexport interface User {\n    id: string;\n    email: string;\n    [key: string]: unknown;\n}\n\nexport interface Session {\n    id: string;\n    userId: string;\n    expiresAt: Date;\n}\n\nexport interface AuthResult {\n    success: boolean;\n    user?: User;\n    token?: string;\n    error?: string;\n}\n\n/**\n * Create an authentication service\n *\n * @example\n * ```typescript\n * const auth = createAuth({\n *   jwtSecret: env.JWT_SECRET,\n *   sessionDuration: 60 * 60 * 24 * 7, // 7 days\n *   database: database\n * });\n *\n * // Create a token for a user\n * const result = await auth.createToken({ id: '123', email: 'user@example.com' });\n *\n * // Verify a token\n * const user = await auth.verifyToken(request.headers.get('Authorization'));\n * ```\n */\nexport function createAuth(options: AuthOptions) {\n    const sessionDuration = options.sessionDuration || 60 * 60 * 24 * 7; // 7 days default\n\n    return {\n        /**\n         * Create a JWT token for a user\n         */\n        async createToken(user: User): Promise<AuthResult> {\n            try {\n                const header = { alg: \"HS256\", typ: \"JWT\" };\n                const now = Math.floor(Date.now() / 1000);\n                const payload = {\n                    sub: user.id,\n                    email: user.email,\n                    iat: now,\n                    exp: now + sessionDuration,\n                };\n\n                const encodedHeader = base64urlEncode(JSON.stringify(header));\n                const encodedPayload = base64urlEncode(JSON.stringify(payload));\n                const data = `${encodedHeader}.${encodedPayload}`;\n\n                // Sign the token\n                const encoder = new TextEncoder();\n                const key = await crypto.subtle.importKey(\n                    \"raw\",\n                    encoder.encode(options.jwtSecret),\n                    { name: \"HMAC\", hash: \"SHA-256\" },\n                    false,\n                    [\"sign\"],\n                );\n\n                const signature = await crypto.subtle.sign(\"HMAC\", key, encoder.encode(data));\n                const encodedSignature = base64urlEncode(String.fromCharCode(...new Uint8Array(signature)));\n\n                const token = `${data}.${encodedSignature}`;\n\n                return { success: true, user, token };\n            } catch (error) {\n                return { success: false, error: \"Failed to create token\" };\n            }\n        },\n\n        /**\n         * Verify a JWT token\n         */\n        async verifyToken(authHeader: string | null): Promise<AuthResult> {\n            if (!authHeader?.startsWith(\"Bearer \")) {\n                return { success: false, error: \"Invalid authorization header\" };\n            }\n\n            const token = authHeader.slice(7);\n\n            try {\n                const [encodedHeader, encodedPayload, encodedSignature] = token.split(\".\");\n\n                if (!encodedHeader || !encodedPayload || !encodedSignature) {\n                    return { success: false, error: \"Invalid token format\" };\n                }\n\n                // Verify signature\n                const data = `${encodedHeader}.${encodedPayload}`;\n                const encoder = new TextEncoder();\n                const key = await crypto.subtle.importKey(\n                    \"raw\",\n                    encoder.encode(options.jwtSecret),\n                    { name: \"HMAC\", hash: \"SHA-256\" },\n                    false,\n                    [\"verify\"],\n                );\n\n                const signatureBytes = Uint8Array.from(base64urlDecode(encodedSignature), (c) => c.charCodeAt(0));\n                const isValid = await crypto.subtle.verify(\"HMAC\", key, signatureBytes, encoder.encode(data));\n\n                if (!isValid) {\n                    return { success: false, error: \"Invalid token signature\" };\n                }\n\n                // Parse payload\n                const payload = JSON.parse(base64urlDecode(encodedPayload));\n\n                // Check expiration\n                if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {\n                    return { success: false, error: \"Token expired\" };\n                }\n\n                const user: User = {\n                    id: payload.sub,\n                    email: payload.email,\n                };\n\n                return { success: true, user };\n            } catch {\n                return { success: false, error: \"Invalid token\" };\n            }\n        },\n\n        /**\n         * Create a session (for cookie-based auth)\n         */\n        async createSession(user: User): Promise<AuthResult> {\n            if (!options.database) {\n                return { success: false, error: \"Database required for sessions\" };\n            }\n\n            const sessionId = crypto.randomUUID();\n            const expiresAt = new Date(Date.now() + sessionDuration * 1000);\n\n            try {\n                await options.database.execute(\"INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)\", [\n                    sessionId,\n                    user.id,\n                    expiresAt.toISOString(),\n                ]);\n\n                return {\n                    success: true,\n                    user,\n                    token: sessionId,\n                };\n            } catch {\n                return { success: false, error: \"Failed to create session\" };\n            }\n        },\n\n        /**\n         * Verify a session\n         */\n        async verifySession(sessionId: string): Promise<AuthResult> {\n            if (!options.database) {\n                return { success: false, error: \"Database required for sessions\" };\n            }\n\n            try {\n                const result = await options.database.query(\n                    'SELECT s.*, u.id as user_id, u.email FROM sessions s JOIN users u ON s.user_id = u.id WHERE s.id = ? AND s.expires_at > datetime(\"now\")',\n                    [sessionId],\n                );\n\n                if (result.results.length === 0) {\n                    return { success: false, error: \"Invalid or expired session\" };\n                }\n\n                const row = result.results[0] as Record<string, string>;\n                const user: User = {\n                    id: row.user_id,\n                    email: row.email,\n                };\n\n                return { success: true, user };\n            } catch {\n                return { success: false, error: \"Failed to verify session\" };\n            }\n        },\n    };\n}\n\n// Types are already exported via interfaces above\n","/**\n * Database Module\n *\n * Provides createDatabase() for D1 database operations.\n */\n\nimport type { D1Database, D1Result, DatabaseOptions } from \"./types\";\nexport type { D1Database, D1Result, DatabaseOptions };\n\n/**\n * Validates SQL identifiers (table names, column names)\n * Only allows alphanumeric characters and underscores, starting with a letter or underscore\n */\nfunction validateIdentifier(name: string): string {\n    const VALID_IDENTIFIER = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n    if (!VALID_IDENTIFIER.test(name)) {\n        throw new Error(`Invalid SQL identifier: ${name}`);\n    }\n    return name;\n}\n\n/**\n * Create a database service\n *\n * @example\n * ```typescript\n * const database = createDatabase({\n *   binding: env.DB\n * });\n *\n * // Query users\n * const users = await database.query('SELECT * FROM users WHERE active = ?', [true]);\n *\n * // Get single user\n * const user = await database.get('SELECT * FROM users WHERE id = ?', ['123']);\n *\n * // Insert user\n * await database.execute('INSERT INTO users (id, email) VALUES (?, ?)', ['123', 'user@example.com']);\n *\n * // Update user\n * await database.execute('UPDATE users SET email = ? WHERE id = ?', ['new@example.com', '123']);\n *\n * // Delete user\n * await database.execute('DELETE FROM users WHERE id = ?', ['123']);\n * ```\n */\nexport function createDatabase(options: DatabaseOptions) {\n    const db = options.binding;\n\n    return {\n        /**\n         * Execute a query and return all results\n         */\n        async query<T = unknown>(sql: string, params: unknown[] = []): Promise<D1Result<T>> {\n            try {\n                const statement = db.prepare(sql);\n                const result = await statement.bind(...params).all<T>();\n                return result;\n            } catch (error) {\n                return {\n                    results: [],\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Unknown error\",\n                };\n            }\n        },\n\n        /**\n         * Execute a query and return first result only\n         */\n        async get<T = unknown>(sql: string, params: unknown[] = []): Promise<T | null> {\n            try {\n                const statement = db.prepare(sql);\n                const result = await statement.bind(...params).first<T>();\n                return result;\n            } catch {\n                return null;\n            }\n        },\n\n        /**\n         * Execute a write query (INSERT, UPDATE, DELETE)\n         */\n        async execute(sql: string, params: unknown[] = []): Promise<D1Result> {\n            try {\n                const statement = db.prepare(sql);\n                const result = await statement.bind(...params).run();\n                return result;\n            } catch (error) {\n                return {\n                    results: [],\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Unknown error\",\n                };\n            }\n        },\n\n        /**\n         * Insert a record and return the ID\n         */\n        async insert(table: string, data: Record<string, unknown>): Promise<string | number | null> {\n            // Validate table name\n            validateIdentifier(table);\n\n            const keys = Object.keys(data);\n            const values = Object.values(data);\n\n            // Validate column names\n            keys.forEach(validateIdentifier);\n\n            const placeholders = keys.map(() => \"?\").join(\", \");\n            const sql = `INSERT INTO ${table} (${keys.join(\", \")}) VALUES (${placeholders})`;\n\n            const result = await this.execute(sql, values);\n            return result.meta?.last_row_id ?? null;\n        },\n\n        /**\n         * Update records\n         */\n        async update(\n            table: string,\n            data: Record<string, unknown>,\n            whereClause: string,\n            whereParams: unknown[],\n        ): Promise<number> {\n            // Validate table name\n            validateIdentifier(table);\n\n            const keys = Object.keys(data);\n            const values = Object.values(data);\n\n            // Validate column names\n            keys.forEach(validateIdentifier);\n\n            const setClause = keys.map((key) => `${key} = ?`).join(\", \");\n            const sql = `UPDATE ${table} SET ${setClause} WHERE ${whereClause}`;\n\n            const result = await this.execute(sql, [...values, ...whereParams]);\n            return result.meta?.changes ?? 0;\n        },\n\n        /**\n         * Delete records\n         */\n        async delete(table: string, whereClause: string, whereParams: unknown[]): Promise<number> {\n            // Validate table name\n            validateIdentifier(table);\n\n            const sql = `DELETE FROM ${table} WHERE ${whereClause}`;\n\n            const result = await this.execute(sql, whereParams);\n            return result.meta?.changes ?? 0;\n        },\n\n        /**\n         * Run multiple queries in a batch\n         */\n        async batch<T = unknown>(queries: { sql: string; params: unknown[] }[]): Promise<D1Result<T>[]> {\n            try {\n                const statements = queries.map((q) => db.prepare(q.sql).bind(...q.params));\n                const results = await db.batch<T>(statements);\n                return results;\n            } catch (error) {\n                return [\n                    {\n                        results: [],\n                        success: false,\n                        error: error instanceof Error ? error.message : \"Unknown error\",\n                    },\n                ];\n            }\n        },\n\n        /**\n         * Get the raw D1 binding for advanced usage\n         */\n        getBinding(): D1Database {\n            return db;\n        },\n    };\n}\n\nexport type DatabaseService = ReturnType<typeof createDatabase>;\n","/**\n * Cache Module\n *\n * Provides createCache() for KV caching operations.\n */\n\nimport type { KVNamespace } from \"@cloudflare/workers-types\";\n\nexport interface CacheOptions {\n    binding: KVNamespace;\n    defaultTTL?: number; // in seconds\n}\n\nexport interface CacheEntry<T> {\n    value: T;\n    expiresAt?: number;\n}\n\n/**\n * Create a cache service\n *\n * @example\n * ```typescript\n * const cache = createCache({\n *   binding: env.CACHE,\n *   defaultTTL: 60 * 5 // 5 minutes default\n * });\n *\n * // Save to cache\n * await cache.set('user:123', user, 60 * 10); // 10 minutes\n *\n * // Get from cache\n * const user = await cache.get('user:123');\n * if (user) {\n *   return jsonResponse(user);\n * }\n *\n * // Delete from cache\n * await cache.delete('user:123');\n *\n * // Check if exists\n * const exists = await cache.has('user:123');\n * ```\n */\nexport function createCache(options: CacheOptions) {\n    const kv = options.binding;\n    const defaultTTL = options.defaultTTL;\n\n    return {\n        /**\n         * Get a value from cache\n         */\n        async get<T = unknown>(key: string): Promise<T | null> {\n            try {\n                const value = await kv.get(key, \"json\");\n                return value as T | null;\n            } catch {\n                return null;\n            }\n        },\n\n        /**\n         * Get a string value from cache\n         */\n        async getString(key: string): Promise<string | null> {\n            try {\n                return await kv.get(key, \"text\");\n            } catch {\n                return null;\n            }\n        },\n\n        /**\n         * Save a value to cache\n         */\n        async set<T = unknown>(key: string, value: T, ttlSeconds?: number): Promise<void> {\n            const ttl = ttlSeconds ?? defaultTTL;\n\n            try {\n                if (ttl) {\n                    await kv.put(key, JSON.stringify(value), { expirationTtl: ttl });\n                } else {\n                    await kv.put(key, JSON.stringify(value));\n                }\n            } catch (error) {\n                console.error(\"Cache set error:\", error);\n            }\n        },\n\n        /**\n         * Save a string to cache\n         */\n        async setString(key: string, value: string, ttlSeconds?: number): Promise<void> {\n            const ttl = ttlSeconds ?? defaultTTL;\n\n            try {\n                if (ttl) {\n                    await kv.put(key, value, { expirationTtl: ttl });\n                } else {\n                    await kv.put(key, value);\n                }\n            } catch (error) {\n                console.error(\"Cache set error:\", error);\n            }\n        },\n\n        /**\n         * Delete a value from cache\n         */\n        async delete(key: string): Promise<void> {\n            try {\n                await kv.delete(key);\n            } catch (error) {\n                console.error(\"Cache delete error:\", error);\n            }\n        },\n\n        /**\n         * Check if a key exists in cache\n         */\n        async has(key: string): Promise<boolean> {\n            const value = await kv.get(key);\n            return value !== null;\n        },\n\n        /**\n         * Get multiple values from cache\n         */\n        async getMultiple<T = unknown>(keys: string[]): Promise<Record<string, T | null>> {\n            const results: Record<string, T | null> = {};\n\n            await Promise.all(\n                keys.map(async (key) => {\n                    results[key] = await this.get<T>(key);\n                }),\n            );\n\n            return results;\n        },\n\n        /**\n         * Get value or compute and cache it\n         */\n        async getOrSet<T = unknown>(key: string, compute: () => Promise<T>, ttlSeconds?: number): Promise<T> {\n            const cached = await this.get<T>(key);\n\n            if (cached !== null) {\n                return cached;\n            }\n\n            const value = await compute();\n            await this.set(key, value, ttlSeconds);\n            return value;\n        },\n\n        /**\n         * List keys with optional prefix\n         */\n        async listKeys(options?: { prefix?: string; limit?: number; cursor?: string }): Promise<{\n            keys: string[];\n            cursor?: string;\n        }> {\n            const result = await kv.list({\n                prefix: options?.prefix,\n                limit: options?.limit,\n                cursor: options?.cursor,\n            });\n\n            return {\n                keys: result.keys.map((k) => k.name),\n                cursor: result.list_complete ? undefined : result.cursor,\n            };\n        },\n\n        /**\n         * Get the raw KV binding for advanced usage\n         */\n        getBinding(): KVNamespace {\n            return kv;\n        },\n    };\n}\n\nexport type CacheService = ReturnType<typeof createCache>;\nexport type { KVNamespace };\n","/**\n * Storage Module\n *\n * Provides createStorage() for R2 object storage operations.\n */\n\nimport type { R2Bucket } from \"@cloudflare/workers-types\";\n\nexport interface StorageOptions {\n    binding: R2Bucket;\n}\n\nexport interface UploadResult {\n    success: boolean;\n    key?: string;\n    size?: number;\n    etag?: string;\n    url?: string;\n    error?: string;\n}\n\nexport interface DownloadResult {\n    success: boolean;\n    data?: ReadableStream;\n    contentType?: string;\n    size?: number;\n    error?: string;\n}\n\n/**\n * Create a storage service for R2\n *\n * @example\n * ```typescript\n * const storage = createStorage({\n *   binding: env.STORAGE\n * });\n *\n * // Upload a file\n * const result = await storage.upload('documents/report.pdf', fileStream, {\n *   contentType: 'application/pdf'\n * });\n *\n * // Download a file\n * const file = await storage.download('documents/report.pdf');\n * if (file.success) {\n *   return new Response(file.data);\n * }\n *\n * // Delete a file\n * await storage.delete('documents/report.pdf');\n *\n * // Check if file exists\n * const exists = await storage.exists('documents/report.pdf');\n *\n * // List files\n * const files = await storage.list('documents/');\n * ```\n */\nexport function createStorage(options: StorageOptions) {\n    const bucket = options.binding;\n\n    return {\n        /**\n         * Upload a file to storage\n         */\n        async upload(\n            key: string,\n            data: ReadableStream | ArrayBuffer | string | Blob,\n            metadata?: {\n                contentType?: string;\n                customMetadata?: Record<string, string>;\n            },\n        ): Promise<UploadResult> {\n            try {\n                const object = await bucket.put(key, data, {\n                    httpMetadata: metadata?.contentType ? { contentType: metadata.contentType } : undefined,\n                    customMetadata: metadata?.customMetadata,\n                });\n\n                return {\n                    success: true,\n                    key: object.key,\n                    size: object.size,\n                    etag: object.etag,\n                };\n            } catch (error) {\n                return {\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Upload failed\",\n                };\n            }\n        },\n\n        /**\n         * Download a file from storage\n         */\n        async download(key: string): Promise<DownloadResult> {\n            try {\n                const object = await bucket.get(key);\n\n                if (!object) {\n                    return { success: false, error: \"File not found\" };\n                }\n\n                return {\n                    success: true,\n                    data: object.body,\n                    contentType: object.httpMetadata?.contentType,\n                    size: object.size,\n                };\n            } catch (error) {\n                return {\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Download failed\",\n                };\n            }\n        },\n\n        /**\n         * Get file metadata without downloading\n         */\n        async getMetadata(key: string): Promise<{\n            success: boolean;\n            size?: number;\n            etag?: string;\n            contentType?: string;\n            uploaded?: Date;\n            customMetadata?: Record<string, string>;\n            error?: string;\n        }> {\n            try {\n                const object = await bucket.head(key);\n\n                if (!object) {\n                    return { success: false, error: \"File not found\" };\n                }\n\n                return {\n                    success: true,\n                    size: object.size,\n                    etag: object.etag,\n                    contentType: object.httpMetadata?.contentType,\n                    uploaded: object.uploaded,\n                    customMetadata: object.customMetadata,\n                };\n            } catch (error) {\n                return {\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Failed to get metadata\",\n                };\n            }\n        },\n\n        /**\n         * Delete a file from storage\n         */\n        async delete(key: string): Promise<{ success: boolean; error?: string }> {\n            try {\n                await bucket.delete(key);\n                return { success: true };\n            } catch (error) {\n                return {\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Delete failed\",\n                };\n            }\n        },\n\n        /**\n         * Delete multiple files\n         */\n        async deleteMultiple(keys: string[]): Promise<{ success: boolean; error?: string }> {\n            try {\n                await bucket.delete(keys);\n                return { success: true };\n            } catch (error) {\n                return {\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Delete failed\",\n                };\n            }\n        },\n\n        /**\n         * Check if a file exists\n         */\n        async exists(key: string): Promise<boolean> {\n            try {\n                const object = await bucket.head(key);\n                return object !== null;\n            } catch {\n                return false;\n            }\n        },\n\n        /**\n         * List files in storage\n         */\n        async list(options?: { prefix?: string; limit?: number; cursor?: string }): Promise<{\n            success: boolean;\n            files: Array<{\n                key: string;\n                size: number;\n                etag: string;\n                uploaded: Date;\n            }>;\n            cursor?: string;\n            error?: string;\n        }> {\n            try {\n                const result = await bucket.list({\n                    prefix: options?.prefix,\n                    limit: options?.limit,\n                    cursor: options?.cursor,\n                });\n\n                return {\n                    success: true,\n                    files: result.objects.map((obj) => ({\n                        key: obj.key,\n                        size: obj.size,\n                        etag: obj.etag,\n                        uploaded: obj.uploaded,\n                    })),\n                    cursor: result.truncated ? result.cursor : undefined,\n                };\n            } catch (error) {\n                return {\n                    success: false,\n                    files: [],\n                    error: error instanceof Error ? error.message : \"List failed\",\n                };\n            }\n        },\n\n        /**\n         * Get a signed URL for temporary access (if using R2 with public access)\n         */\n        async getPublicUrl(key: string): Promise<string> {\n            // Note: This assumes the bucket is configured for public access\n            // For private buckets, you'd need to implement signed URLs differently\n            return `https://storage.example.com/${key}`;\n        },\n\n        /**\n         * Get the raw R2 binding for advanced usage\n         */\n        getBinding(): R2Bucket {\n            return bucket;\n        },\n    };\n}\n\nexport type StorageService = ReturnType<typeof createStorage>;\nexport type { R2Bucket };\n","/**\n * Queue Module\n *\n * Provides createQueue() for Queue handling in Cloudflare Workers.\n */\n\nimport type { Queue } from \"@cloudflare/workers-types\";\n\nexport interface QueueOptions {\n    binding: Queue<unknown>;\n}\n\nexport interface QueueMessage<T = unknown> {\n    id: string;\n    body: T;\n    timestamp: number;\n    attempts: number;\n}\n\nexport interface SendResult {\n    success: boolean;\n    error?: string;\n}\n\nexport interface QueueHandler<T = unknown> {\n    (message: T): Promise<void> | void;\n}\n\n/**\n * Create a queue service\n *\n * @example\n * ```typescript\n * const queue = createQueue({\n *   binding: env.MY_QUEUE\n * });\n *\n * // Send a message to the queue\n * await queue.send({ type: 'send-email', to: 'user@example.com' });\n *\n * // Send multiple messages\n * await queue.sendBatch([\n *   { type: 'send-email', to: 'user1@example.com' },\n *   { type: 'send-email', to: 'user2@example.com' }\n * ]);\n * ```\n */\nexport function createQueue<T = unknown>(options: QueueOptions) {\n    const queueBinding = options.binding;\n\n    return {\n        /**\n         * Send a single message to the queue\n         */\n        async send(body: T, options?: { delaySeconds?: number }): Promise<SendResult> {\n            try {\n                await queueBinding.send(body, { delaySeconds: options?.delaySeconds });\n                return { success: true };\n            } catch (error) {\n                return {\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Failed to send message\",\n                };\n            }\n        },\n\n        /**\n         * Send multiple messages to the queue\n         */\n        async sendBatch(messages: T[]): Promise<SendResult> {\n            try {\n                const batch = messages.map((body) => ({ body }));\n                await queueBinding.sendBatch(batch);\n                return { success: true };\n            } catch (error) {\n                return {\n                    success: false,\n                    error: error instanceof Error ? error.message : \"Failed to send batch\",\n                };\n            }\n        },\n\n        /**\n         * Get the raw Queue binding for advanced usage\n         */\n        getBinding(): Queue<unknown> {\n            return queueBinding;\n        },\n    };\n}\n\n/**\n * Create a queue consumer handler\n *\n * @example\n * ```typescript\n * const emailQueue = createQueue({ binding: env.EMAIL_QUEUE });\n *\n * export default {\n *   async fetch(request, env, ctx) {\n *     // Regular HTTP handler\n *   },\n *\n *   async queue(batch, env, ctx) {\n *     // Queue consumer handler\n *     const handler = createQueueConsumer(async (message) => {\n *       console.log('Processing:', message);\n *       // Process the message\n *     });\n *\n *     await handler(batch, env, ctx);\n *   }\n * };\n * ```\n */\nexport function createQueueConsumer<T = unknown>(\n    processor: QueueHandler<T>,\n): (batch: MessageBatch<T>, _env: unknown, _ctx: ExecutionContext) => Promise<void> {\n    return async (batch: MessageBatch<T>, _env: unknown, _ctx: ExecutionContext) => {\n        for (const message of batch.messages) {\n            try {\n                await processor(message.body);\n                message.ack();\n            } catch (error) {\n                console.error(\"Failed to process message:\", error);\n                message.retry();\n            }\n        }\n    };\n}\n\nexport type QueueService<T = unknown> = ReturnType<typeof createQueue<T>>;\nexport type { Queue };\n\n// Type for MessageBatch from Cloudflare\ntype MessageBatch<T> = {\n    queue: string;\n    messages: Array<{\n        id: string;\n        timestamp: Date;\n        body: T;\n        attempts: number;\n        ack: () => void;\n        retry: () => void;\n    }>;\n};\n","/**\n * Logging Module\n *\n * Provides createLogger() for structured logging.\n */\n\nexport interface LoggerOptions {\n    level?: \"debug\" | \"info\" | \"warn\" | \"error\";\n    service?: string;\n    environment?: string;\n}\n\nexport interface LogEntry {\n    timestamp: string;\n    level: string;\n    message: string;\n    service?: string;\n    environment?: string;\n    data?: Record<string, unknown>;\n}\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3,\n};\n\n/**\n * Create a structured logger\n *\n * @example\n * ```typescript\n * const logger = createLogger({\n *   level: 'info',\n *   service: 'my-api',\n *   environment: 'production'\n * });\n *\n * // Log messages\n * logger.debug('Debug information', { userId: '123' });\n * logger.info('User logged in', { userId: '123' });\n * logger.warn('Rate limit approaching', { userId: '123' });\n * logger.error('Failed to save user', { error: err.message });\n * ```\n */\nexport function createLogger(options: LoggerOptions = {}) {\n    const minLevel = options.level || \"info\";\n    const service = options.service || \"app\";\n    const environment = options.environment || \"development\";\n\n    function shouldLog(level: LogLevel): boolean {\n        return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];\n    }\n\n    function formatLog(level: LogLevel, message: string, data?: Record<string, unknown>): LogEntry {\n        return {\n            timestamp: new Date().toISOString(),\n            level: level.toUpperCase(),\n            message,\n            service,\n            environment,\n            ...(data && { data }),\n        };\n    }\n\n    function output(entry: LogEntry): void {\n        const output = JSON.stringify(entry);\n\n        switch (entry.level) {\n            case \"ERROR\":\n                console.error(output);\n                break;\n            case \"WARN\":\n                console.warn(output);\n                break;\n            default:\n                console.log(output);\n        }\n    }\n\n    return {\n        /**\n         * Log debug message\n         */\n        debug(message: string, data?: Record<string, unknown>): void {\n            if (shouldLog(\"debug\")) {\n                output(formatLog(\"debug\", message, data));\n            }\n        },\n\n        /**\n         * Log info message\n         */\n        info(message: string, data?: Record<string, unknown>): void {\n            if (shouldLog(\"info\")) {\n                output(formatLog(\"info\", message, data));\n            }\n        },\n\n        /**\n         * Log warning message\n         */\n        warn(message: string, data?: Record<string, unknown>): void {\n            if (shouldLog(\"warn\")) {\n                output(formatLog(\"warn\", message, data));\n            }\n        },\n\n        /**\n         * Log error message\n         */\n        error(message: string, data?: Record<string, unknown>): void {\n            if (shouldLog(\"error\")) {\n                output(formatLog(\"error\", message, data));\n            }\n        },\n\n        /**\n         * Create a child logger with additional context\n         */\n        child(additionalContext: Record<string, unknown>) {\n            return {\n                debug(message: string, data?: Record<string, unknown>): void {\n                    if (shouldLog(\"debug\")) {\n                        output(formatLog(\"debug\", message, { ...additionalContext, ...data }));\n                    }\n                },\n                info(message: string, data?: Record<string, unknown>): void {\n                    if (shouldLog(\"info\")) {\n                        output(formatLog(\"info\", message, { ...additionalContext, ...data }));\n                    }\n                },\n                warn(message: string, data?: Record<string, unknown>): void {\n                    if (shouldLog(\"warn\")) {\n                        output(formatLog(\"warn\", message, { ...additionalContext, ...data }));\n                    }\n                },\n                error(message: string, data?: Record<string, unknown>): void {\n                    if (shouldLog(\"error\")) {\n                        output(formatLog(\"error\", message, { ...additionalContext, ...data }));\n                    }\n                },\n                child(nestedContext: Record<string, unknown>) {\n                    return createLogger({ level: minLevel, service, environment }).child({\n                        ...additionalContext,\n                        ...nestedContext,\n                    });\n                },\n                getLevel(): string {\n                    return minLevel;\n                },\n            };\n        },\n\n        /**\n         * Get current log level\n         */\n        getLevel(): string {\n            return minLevel;\n        },\n    };\n}\n\nexport type Logger = ReturnType<typeof createLogger>;\n","/**\n * Security Module\n *\n * Provides rate limiting and validation utilities.\n */\n\nimport type { Middleware, RequestContext } from \"../core/types\";\nimport { errorResponse } from \"../core/response\";\n\nexport interface RateLimitOptions {\n    maxRequests: number;\n    windowSeconds: number;\n    keyGenerator?: (request: Request) => string;\n}\n\nexport interface ValidationSchema {\n    [key: string]: {\n        type: \"string\" | \"number\" | \"boolean\" | \"email\";\n        required?: boolean;\n        minLength?: number;\n        maxLength?: number;\n        pattern?: RegExp;\n    };\n}\n\n/**\n * Create rate limiting middleware\n *\n *  WARNING: This rate limiter uses an in-memory Map which has limitations:\n * - It does not share state across Cloudflare Worker isolates (each request may hit a different isolate)\n * - The map grows unbounded and resets on cold starts\n * - For production use, consider using KV or D1 for distributed rate limiting\n *\n * @example\n * ```typescript\n * app.use(rateLimit({\n *   maxRequests: 100,\n *   windowSeconds: 60\n * }));\n * ```\n */\nexport function rateLimit(options: RateLimitOptions): Middleware {\n    const store = new Map<string, { count: number; resetAt: number }>();\n\n    return async (context: RequestContext): Promise<Response | void> => {\n        const key = options.keyGenerator\n            ? options.keyGenerator(context.request)\n            : context.request.headers.get(\"CF-Connecting-IP\") || \"unknown\";\n\n        const now = Date.now();\n        const windowMs = options.windowSeconds * 1000;\n\n        let record = store.get(key);\n\n        if (!record || now > record.resetAt) {\n            record = { count: 0, resetAt: now + windowMs };\n            store.set(key, record);\n        }\n\n        record.count++;\n\n        if (record.count > options.maxRequests) {\n            return errorResponse(\"Rate limit exceeded\", 429);\n        }\n        return undefined;\n    };\n}\n\n/**\n * Create request validation middleware\n *\n * @example\n * ```typescript\n * app.use(validateRequest({\n *   email: { type: 'email', required: true },\n *   name: { type: 'string', required: true, minLength: 2, maxLength: 100 }\n * }));\n * ```\n */\nexport function validateRequest(schema: ValidationSchema): Middleware {\n    return async (context: RequestContext): Promise<Response | void> => {\n        const body = context.state.body as Record<string, unknown>;\n\n        if (!body) {\n            return errorResponse(\"Request body required\", 400);\n        }\n\n        const errors: string[] = [];\n\n        for (const [field, rules] of Object.entries(schema)) {\n            const value = body[field];\n\n            // Check required\n            if (rules.required && (value === undefined || value === null || value === \"\")) {\n                errors.push(`${field} is required`);\n                continue;\n            }\n\n            if (value === undefined || value === null) {\n                continue;\n            }\n\n            // Type validation\n            if (rules.type === \"email\") {\n                const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                if (typeof value !== \"string\" || !emailRegex.test(value)) {\n                    errors.push(`${field} must be a valid email`);\n                }\n            } else if (rules.type === \"string\") {\n                if (typeof value !== \"string\") {\n                    errors.push(`${field} must be a string`);\n                } else {\n                    if (rules.minLength && value.length < rules.minLength) {\n                        errors.push(`${field} must be at least ${rules.minLength} characters`);\n                    }\n                    if (rules.maxLength && value.length > rules.maxLength) {\n                        errors.push(`${field} must be at most ${rules.maxLength} characters`);\n                    }\n                    if (rules.pattern && !rules.pattern.test(value)) {\n                        errors.push(`${field} format is invalid`);\n                    }\n                }\n            } else if (rules.type === \"number\") {\n                if (typeof value !== \"number\" || isNaN(value)) {\n                    errors.push(`${field} must be a number`);\n                }\n            } else if (rules.type === \"boolean\") {\n                if (typeof value !== \"boolean\") {\n                    errors.push(`${field} must be a boolean`);\n                }\n            }\n        }\n\n        if (errors.length > 0) {\n            return errorResponse(errors.join(\", \"), 400);\n        }\n        return undefined;\n    };\n}\n\n// Types are already exported via interfaces above\n","/**\n * Cloudflare Kit Error System\n *\n * Structured error handling with operational and programming error distinction.\n */\n\n/**\n * Base error class for all Cloudflare Kit errors\n */\nexport class CloudflareKitError extends Error {\n    readonly code: string;\n    readonly statusCode: number;\n    readonly isOperational: boolean;\n    readonly timestamp: string;\n\n    constructor(message: string, code: string, statusCode: number = 500, isOperational: boolean = true) {\n        super(message);\n        this.name = this.constructor.name;\n        this.code = code;\n        this.statusCode = statusCode;\n        this.isOperational = isOperational;\n        this.timestamp = new Date().toISOString();\n\n        // Stack trace is automatically captured in modern environments\n        // Note: Error.captureStackTrace is Node.js specific, not available in Workers\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n\n    /**\n     * Serialize error to JSON format for API responses\n     */\n    toJSON(): Record<string, unknown> {\n        return {\n            error: {\n                code: this.code,\n                message: this.message,\n                statusCode: this.statusCode,\n                ...((globalThis as { ENVIRONMENT?: string }).ENVIRONMENT === \"development\" && { stack: this.stack }),\n            },\n        };\n    }\n\n    /**\n     * Create a Response object from this error\n     */\n    toResponse(): Response {\n        return new Response(JSON.stringify(this.toJSON()), {\n            status: this.statusCode,\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n        });\n    }\n}\n\n/**\n * HTTP-specific errors with status codes\n */\nexport class HttpError extends CloudflareKitError {\n    constructor(message: string, statusCode: number = 500, code?: string) {\n        super(message, code || `HTTP_${statusCode}`, statusCode, true);\n    }\n\n    static badRequest(message = \"Bad Request\"): HttpError {\n        return new HttpError(message, 400, \"BAD_REQUEST\");\n    }\n\n    static unauthorized(message = \"Unauthorized\"): HttpError {\n        return new HttpError(message, 401, \"UNAUTHORIZED\");\n    }\n\n    static forbidden(message = \"Forbidden\"): HttpError {\n        return new HttpError(message, 403, \"FORBIDDEN\");\n    }\n\n    static notFound(message = \"Not Found\"): HttpError {\n        return new HttpError(message, 404, \"NOT_FOUND\");\n    }\n\n    static methodNotAllowed(message = \"Method Not Allowed\"): HttpError {\n        return new HttpError(message, 405, \"METHOD_NOT_ALLOWED\");\n    }\n\n    static conflict(message = \"Conflict\"): HttpError {\n        return new HttpError(message, 409, \"CONFLICT\");\n    }\n\n    static unprocessable(message = \"Unprocessable Entity\"): HttpError {\n        return new HttpError(message, 422, \"UNPROCESSABLE_ENTITY\");\n    }\n\n    static tooManyRequests(message = \"Too Many Requests\", retryAfter?: number): RateLimitError {\n        return new RateLimitError(message, retryAfter);\n    }\n\n    static internal(message = \"Internal Server Error\"): HttpError {\n        return new HttpError(message, 500, \"INTERNAL_ERROR\");\n    }\n\n    static notImplemented(message = \"Not Implemented\"): HttpError {\n        return new HttpError(message, 501, \"NOT_IMPLEMENTED\");\n    }\n\n    static badGateway(message = \"Bad Gateway\"): HttpError {\n        return new HttpError(message, 502, \"BAD_GATEWAY\");\n    }\n\n    static serviceUnavailable(message = \"Service Unavailable\"): HttpError {\n        return new HttpError(message, 503, \"SERVICE_UNAVAILABLE\");\n    }\n}\n\n/**\n * Validation errors for input validation failures\n */\nexport class ValidationError extends CloudflareKitError {\n    readonly field?: string;\n    readonly errors: Array<{ field: string; message: string; code?: string }>;\n\n    constructor(\n        message: string,\n        field?: string,\n        errors: Array<{ field: string; message: string; code?: string }> = [],\n    ) {\n        super(message, \"VALIDATION_ERROR\", 400, true);\n        this.field = field;\n        this.errors = errors;\n    }\n\n    override toJSON(): Record<string, unknown> {\n        return {\n            error: {\n                code: this.code,\n                message: this.message,\n                statusCode: this.statusCode,\n                ...(this.field && { field: this.field }),\n                ...(this.errors.length > 0 && { errors: this.errors }),\n            },\n        };\n    }\n\n    static fromZodError(zodError: {\n        issues: Array<{ path: (string | number)[]; message: string; code: string }>;\n    }): ValidationError {\n        const errors = zodError.issues.map((issue) => ({\n            field: issue.path.join(\".\"),\n            message: issue.message,\n            code: issue.code,\n        }));\n\n        return new ValidationError(\n            `Validation failed: ${errors.map((e) => `${e.field} - ${e.message}`).join(\", \")}`,\n            undefined,\n            errors,\n        );\n    }\n}\n\n/**\n * Authentication and authorization errors\n */\nexport class AuthError extends CloudflareKitError {\n    constructor(message: string, code: string = \"AUTH_ERROR\") {\n        super(message, code, 401, true);\n    }\n\n    static invalidToken(message = \"Invalid or expired token\"): AuthError {\n        return new AuthError(message, \"INVALID_TOKEN\");\n    }\n\n    static missingToken(message = \"Authentication required\"): AuthError {\n        return new AuthError(message, \"MISSING_TOKEN\");\n    }\n\n    static expiredToken(message = \"Token has expired\"): AuthError {\n        return new AuthError(message, \"TOKEN_EXPIRED\");\n    }\n\n    static insufficientPermissions(message = \"Insufficient permissions\"): AuthError {\n        return new AuthError(message, \"FORBIDDEN\");\n    }\n\n    static invalidCredentials(message = \"Invalid credentials\"): AuthError {\n        return new AuthError(message, \"INVALID_CREDENTIALS\");\n    }\n}\n\n/**\n * Rate limiting errors with retry information\n */\nexport class RateLimitError extends CloudflareKitError {\n    readonly retryAfter?: number;\n    readonly limit?: number;\n    readonly remaining?: number;\n    readonly resetTime?: number;\n\n    constructor(\n        message: string = \"Too Many Requests\",\n        retryAfter?: number,\n        limit?: number,\n        remaining?: number,\n        resetTime?: number,\n    ) {\n        super(message, \"RATE_LIMITED\", 429, true);\n        this.retryAfter = retryAfter;\n        this.limit = limit;\n        this.remaining = remaining;\n        this.resetTime = resetTime;\n    }\n\n    override toResponse(): Response {\n        const headers: Record<string, string> = {\n            \"Content-Type\": \"application/json\",\n        };\n\n        if (this.retryAfter) {\n            headers[\"Retry-After\"] = String(this.retryAfter);\n        }\n        if (this.limit !== undefined) {\n            headers[\"X-RateLimit-Limit\"] = String(this.limit);\n        }\n        if (this.remaining !== undefined) {\n            headers[\"X-RateLimit-Remaining\"] = String(this.remaining);\n        }\n        if (this.resetTime) {\n            headers[\"X-RateLimit-Reset\"] = String(this.resetTime);\n        }\n\n        return new Response(JSON.stringify(this.toJSON()), {\n            status: this.statusCode,\n            headers,\n        });\n    }\n\n    override toJSON(): Record<string, unknown> {\n        return {\n            error: {\n                code: this.code,\n                message: this.message,\n                statusCode: this.statusCode,\n                ...(this.retryAfter && { retryAfter: this.retryAfter }),\n                ...(this.limit !== undefined && { limit: this.limit }),\n                ...(this.remaining !== undefined && { remaining: this.remaining }),\n                ...(this.resetTime && { resetTime: this.resetTime }),\n            },\n        };\n    }\n}\n\n/**\n * Database operation errors\n */\nexport class DatabaseError extends CloudflareKitError {\n    readonly query?: string;\n    readonly originalError?: Error;\n\n    constructor(message: string, query?: string, originalError?: Error) {\n        super(message, \"DATABASE_ERROR\", 500, false);\n        this.query = query;\n        this.originalError = originalError;\n    }\n}\n\n/**\n * Cache operation errors\n */\nexport class CacheError extends CloudflareKitError {\n    readonly key?: string;\n\n    constructor(message: string, key?: string) {\n        super(message, \"CACHE_ERROR\", 500, false);\n        this.key = key;\n    }\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigError extends CloudflareKitError {\n    readonly key?: string;\n\n    constructor(message: string, key?: string) {\n        super(message, \"CONFIG_ERROR\", 500, false);\n        this.key = key;\n    }\n}\n\n/**\n * Plugin errors\n */\nexport class PluginError extends CloudflareKitError {\n    readonly pluginName?: string;\n\n    constructor(message: string, pluginName?: string) {\n        super(message, \"PLUGIN_ERROR\", 500, false);\n        this.pluginName = pluginName;\n    }\n}\n\n/**\n * Type guard to check if error is a CloudflareKitError\n */\nexport function isCloudflareKitError(error: unknown): error is CloudflareKitError {\n    return error instanceof CloudflareKitError;\n}\n\n/**\n * Type guard to check if error is an operational error\n */\nexport function isOperationalError(error: unknown): boolean {\n    if (isCloudflareKitError(error)) {\n        return error.isOperational;\n    }\n    return false;\n}\n\n/**\n * Global error handler for unhandled errors\n */\nexport function handleError(error: unknown): Response {\n    if (isCloudflareKitError(error)) {\n        return error.toResponse();\n    }\n\n    // Unknown error - don't expose details in production\n    const isDev = (globalThis as { ENVIRONMENT?: string }).ENVIRONMENT === \"development\";\n    const message = isDev && error instanceof Error ? error.message : \"Internal Server Error\";\n\n    return new Response(\n        JSON.stringify({\n            error: {\n                code: \"INTERNAL_ERROR\",\n                message,\n                statusCode: 500,\n                ...(isDev && error instanceof Error && { stack: error.stack }),\n            },\n        }),\n        {\n            status: 500,\n            headers: { \"Content-Type\": \"application/json\" },\n        },\n    );\n}\n","/**\n * Memory-based Rate Limit Store\n *\n * For development use only. Not suitable for production with multiple Worker instances.\n */\n\nimport type { RateLimitStore, RateLimitData } from \"./types\";\n\n/**\n * Create an in-memory rate limit store\n *\n *  WARNING: This store is for development only. Data is not shared\n * across Cloudflare Worker instances and will be lost on cold starts.\n * Use KVRateLimitStore for production.\n */\nexport function createMemoryRateLimitStore(): RateLimitStore {\n    const store = new Map<string, RateLimitData>();\n    const timers = new Map<string, ReturnType<typeof setTimeout>>();\n\n    return {\n        async get(key: string): Promise<RateLimitData | null> {\n            const data = store.get(key);\n            if (!data) return null;\n\n            // Check if expired\n            if (Date.now() > data.resetAt) {\n                store.delete(key);\n                return null;\n            }\n\n            return data;\n        },\n\n        async set(key: string, data: RateLimitData, ttlSeconds: number): Promise<void> {\n            store.set(key, data);\n\n            // Clear existing timer\n            const existingTimer = timers.get(key);\n            if (existingTimer) {\n                clearTimeout(existingTimer);\n            }\n\n            // Set cleanup timer\n            const timer = setTimeout(() => {\n                store.delete(key);\n                timers.delete(key);\n            }, ttlSeconds * 1000);\n\n            timers.set(key, timer);\n        },\n\n        async increment(key: string): Promise<RateLimitData | null> {\n            const data = store.get(key);\n            if (!data) return null;\n\n            // Check if expired\n            if (Date.now() > data.resetAt) {\n                store.delete(key);\n                return null;\n            }\n\n            data.count++;\n            store.set(key, data);\n            return data;\n        },\n\n        async reset(key: string): Promise<void> {\n            store.delete(key);\n            const timer = timers.get(key);\n            if (timer) {\n                clearTimeout(timer);\n                timers.delete(key);\n            }\n        },\n    };\n}\n","/**\n * KV-based Rate Limit Store\n *\n * Production-ready distributed rate limiting using Cloudflare KV.\n */\n\nimport type { RateLimitStore, RateLimitData } from \"./types\";\n\n/**\n * Configuration for KV rate limit store\n */\nexport interface KVRateLimitConfig {\n    /**\n     * KV namespace binding\n     */\n    binding: KVNamespace;\n\n    /**\n     * Key prefix for rate limit entries\n     * @default 'ratelimit:'\n     */\n    prefix?: string;\n}\n\n/**\n * Create a KV-based rate limit store for production use\n *\n * This store provides distributed rate limiting across all Cloudflare\n * Worker instances. Use this in production environments.\n *\n * @example\n * ```typescript\n * const store = createKVRateLimitStore({\n *   binding: env.RATE_LIMIT_KV,\n *   prefix: 'api:'\n * });\n *\n * const limiter = createRateLimiter({\n *   store,\n *   maxRequests: 100,\n *   windowSeconds: 60\n * });\n * ```\n */\nexport function createKVRateLimitStore(config: KVRateLimitConfig): RateLimitStore {\n    const prefix = config.prefix ?? \"ratelimit:\";\n    const kv = config.binding;\n\n    function getKey(key: string): string {\n        return `${prefix}${key}`;\n    }\n\n    return {\n        async get(key: string): Promise<RateLimitData | null> {\n            const data = await kv.get(getKey(key), \"json\");\n            if (!data) return null;\n\n            // Validate the data structure\n            const rateData = data as RateLimitData;\n            if (Date.now() > rateData.resetAt) {\n                // Data expired, clean it up\n                await kv.delete(getKey(key));\n                return null;\n            }\n\n            return rateData;\n        },\n\n        async set(key: string, data: RateLimitData, ttlSeconds: number): Promise<void> {\n            await kv.put(getKey(key), JSON.stringify(data), {\n                expirationTtl: ttlSeconds,\n            });\n        },\n\n        async increment(key: string): Promise<RateLimitData | null> {\n            const fullKey = getKey(key);\n\n            // Get current value\n            const current = (await kv.get(fullKey, \"json\")) as RateLimitData | null;\n            if (!current) return null;\n\n            // Check if expired\n            if (Date.now() > current.resetAt) {\n                await kv.delete(fullKey);\n                return null;\n            }\n\n            // Increment and update\n            // Note: This is not atomic. For true atomic increments,\n            // consider using D1 or a counter service\n            current.count++;\n            const ttl = Math.ceil((current.resetAt - Date.now()) / 1000);\n\n            await kv.put(fullKey, JSON.stringify(current), {\n                expirationTtl: Math.max(ttl, 1),\n            });\n\n            return current;\n        },\n\n        async reset(key: string): Promise<void> {\n            await kv.delete(getKey(key));\n        },\n    };\n}\n","/**\n * Rate Limiter\n *\n * Enterprise-grade rate limiting with pluggable storage backends.\n */\n\nimport { RateLimitError } from \"../../errors\";\nimport type { RateLimiter, RateLimiterConfig, RateLimitResult, RateLimitData } from \"./types\";\n\nexport type {\n    RateLimiter,\n    RateLimiterConfig,\n    RateLimitResult,\n    RateLimitData,\n    RateLimitStore,\n    RateLimitMiddlewareOptions,\n} from \"./types\";\n\nexport { createMemoryRateLimitStore } from \"./memory-store\";\nexport { createKVRateLimitStore } from \"./kv-store\";\n\n/**\n * Create a rate limiter\n *\n * @example\n * ```typescript\n * // Development - Memory store\n * const devLimiter = createRateLimiter({\n *   store: createMemoryRateLimitStore(),\n *   maxRequests: 100,\n *   windowSeconds: 60\n * });\n *\n * // Production - KV store\n * const prodLimiter = createRateLimiter({\n *   store: createKVRateLimitStore({ binding: env.RATE_LIMIT_KV }),\n *   maxRequests: 100,\n *   windowSeconds: 60,\n *   keyGenerator: (req) => req.headers.get('CF-Connecting-IP') ?? 'anonymous'\n * });\n * ```\n */\nexport function createRateLimiter(config: RateLimiterConfig): RateLimiter {\n    const { store, maxRequests = 100, windowSeconds = 60, keyGenerator = defaultKeyGenerator, skip } = config;\n\n    const windowMs = windowSeconds * 1000;\n\n    function defaultKeyGenerator(request: Request): string {\n        return request.headers.get(\"CF-Connecting-IP\") ?? \"anonymous\";\n    }\n\n    async function getRateLimitData(key: string): Promise<RateLimitData | null> {\n        const data = await store.get(key);\n        if (!data) return null;\n\n        // Check if window has expired\n        if (Date.now() > data.resetAt) {\n            await store.reset(key);\n            return null;\n        }\n\n        return data;\n    }\n\n    async function createNewWindow(key: string): Promise<RateLimitData> {\n        const data: RateLimitData = {\n            count: 0,\n            resetAt: Date.now() + windowMs,\n            limit: maxRequests,\n            window: windowSeconds,\n        };\n\n        await store.set(key, data, windowSeconds);\n        return data;\n    }\n\n    return {\n        async check(request: Request): Promise<RateLimitResult> {\n            if (skip?.(request)) {\n                return {\n                    allowed: true,\n                    limit: maxRequests,\n                    remaining: maxRequests,\n                    resetTime: Date.now() + windowMs,\n                };\n            }\n\n            const key = keyGenerator(request);\n            const data = await getRateLimitData(key);\n\n            if (!data) {\n                return {\n                    allowed: true,\n                    limit: maxRequests,\n                    remaining: maxRequests,\n                    resetTime: Date.now() + windowMs,\n                };\n            }\n\n            const remaining = Math.max(0, maxRequests - data.count);\n            const allowed = remaining > 0;\n\n            return {\n                allowed,\n                limit: maxRequests,\n                remaining,\n                resetTime: data.resetAt,\n                ...(!allowed && {\n                    retryAfter: Math.ceil((data.resetAt - Date.now()) / 1000),\n                }),\n            };\n        },\n\n        async consume(request: Request): Promise<RateLimitResult> {\n            if (skip?.(request)) {\n                return {\n                    allowed: true,\n                    limit: maxRequests,\n                    remaining: maxRequests,\n                    resetTime: Date.now() + windowMs,\n                };\n            }\n\n            const key = keyGenerator(request);\n            let data = await getRateLimitData(key);\n\n            if (!data) {\n                data = await createNewWindow(key);\n            }\n\n            // Increment counter\n            const incremented = await store.increment(key);\n            if (incremented) {\n                data.count = incremented.count;\n            } else {\n                // Race condition - create new window\n                data = await createNewWindow(key);\n                await store.increment(key);\n                data.count = 1;\n            }\n\n            const remaining = Math.max(0, maxRequests - data.count);\n            const allowed = data.count <= maxRequests;\n\n            if (!allowed) {\n                const retryAfter = Math.ceil((data.resetAt - Date.now()) / 1000);\n                throw new RateLimitError(\n                    config.message ?? \"Too many requests\",\n                    retryAfter,\n                    maxRequests,\n                    0,\n                    Math.floor(data.resetAt / 1000),\n                );\n            }\n\n            return {\n                allowed: true,\n                limit: maxRequests,\n                remaining,\n                resetTime: data.resetAt,\n            };\n        },\n\n        async reset(key: string): Promise<void> {\n            await store.reset(key);\n        },\n\n        async status(request: Request): Promise<RateLimitResult> {\n            return this.check(request);\n        },\n    };\n}\n\n/**\n * Create rate limit middleware\n */\nexport function rateLimit(limiter: RateLimiter) {\n    return async (request: Request): Promise<Response | undefined> => {\n        try {\n            await limiter.consume(request);\n\n            // Return undefined to continue to next middleware/handler\n            // Headers will be added by the app\n            return undefined;\n        } catch (error) {\n            if (error instanceof RateLimitError) {\n                return error.toResponse();\n            }\n            throw error;\n        }\n    };\n}\n","/**\n * Plugin Registry\n *\n * Manages plugin registration, dependencies, and lifecycle.\n */\n\nimport { PluginError } from \"../errors\";\nimport type { Plugin, PluginContext, PluginOptions, PluginRegistryEntry, PluginHooks } from \"./types\";\n\n/**\n * Plugin Registry class\n */\nexport class PluginRegistry {\n    private plugins = new Map<string, PluginRegistryEntry>();\n    private hooks = new Map<keyof PluginHooks, Set<PluginHooks[keyof PluginHooks]>>();\n    private installedOrder: string[] = [];\n\n    /**\n     * Register a plugin\n     */\n    register(plugin: Plugin, options: PluginOptions = {}): void {\n        if (this.plugins.has(plugin.name)) {\n            throw new PluginError(`Plugin \"${plugin.name}\" is already registered`, plugin.name);\n        }\n\n        // Check dependencies\n        if (plugin.dependencies) {\n            for (const dep of plugin.dependencies) {\n                if (!this.plugins.has(dep)) {\n                    throw new PluginError(\n                        `Plugin \"${plugin.name}\" requires \"${dep}\" which is not registered`,\n                        plugin.name,\n                    );\n                }\n            }\n        }\n\n        this.plugins.set(plugin.name, {\n            plugin,\n            options: {\n                enabled: true,\n                priority: 100,\n                ...options,\n            },\n            installed: false,\n        });\n\n        // Register hooks\n        if (plugin.hooks) {\n            for (const [event, handler] of Object.entries(plugin.hooks)) {\n                if (handler) {\n                    this.on(event as keyof PluginHooks, handler as PluginHooks[keyof PluginHooks]);\n                }\n            }\n        }\n    }\n\n    /**\n     * Unregister a plugin\n     */\n    unregister(name: string): void {\n        const entry = this.plugins.get(name);\n        if (!entry) {\n            throw new PluginError(`Plugin \"${name}\" is not registered`, name);\n        }\n\n        if (entry.installed) {\n            throw new PluginError(`Cannot unregister installed plugin \"${name}\". Shutdown the app first.`, name);\n        }\n\n        // Check if other plugins depend on this\n        for (const [pluginName, otherEntry] of this.plugins) {\n            if (otherEntry.plugin.dependencies?.includes(name)) {\n                throw new PluginError(`Cannot unregister \"${name}\" because \"${pluginName}\" depends on it`, name);\n            }\n        }\n\n        this.plugins.delete(name);\n    }\n\n    /**\n     * Install all registered plugins\n     */\n    async installAll(context: PluginContext): Promise<void> {\n        const sorted = this.getSortedPlugins();\n\n        for (const entry of sorted) {\n            if (entry.options.enabled && !entry.installed) {\n                try {\n                    await entry.plugin.install(context);\n                    entry.installed = true;\n                    this.installedOrder.push(entry.plugin.name);\n                    context.logger.debug(`Plugin \"${entry.plugin.name}\" installed successfully`);\n                } catch (error) {\n                    entry.error = error instanceof Error ? error : new Error(String(error));\n                    throw new PluginError(\n                        `Failed to install plugin \"${entry.plugin.name}\": ${entry.error.message}`,\n                        entry.plugin.name,\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Get sorted plugins by priority and dependencies\n     */\n    private getSortedPlugins(): PluginRegistryEntry[] {\n        const entries = Array.from(this.plugins.values());\n\n        return entries.sort((a, b) => {\n            // First sort by priority\n            const priorityDiff = (a.options.priority ?? 100) - (b.options.priority ?? 100);\n            if (priorityDiff !== 0) return priorityDiff;\n\n            // Then by dependency order\n            if (a.plugin.dependencies?.includes(b.plugin.name)) return 1;\n            if (b.plugin.dependencies?.includes(a.plugin.name)) return -1;\n\n            return 0;\n        });\n    }\n\n    /**\n     * Register a hook handler\n     */\n    on<K extends keyof PluginHooks>(event: K, handler: PluginHooks[K]): void {\n        if (!this.hooks.has(event)) {\n            this.hooks.set(event, new Set());\n        }\n        this.hooks.get(event)!.add(handler);\n    }\n\n    /**\n     * Unregister a hook handler\n     */\n    off<K extends keyof PluginHooks>(event: K, handler: PluginHooks[K]): void {\n        this.hooks.get(event)?.delete(handler);\n    }\n\n    /**\n     * Emit a hook event to all registered handlers\n     */\n    async emit<K extends keyof PluginHooks>(event: K, ...args: Parameters<NonNullable<PluginHooks[K]>>): Promise<void> {\n        const handlers = this.hooks.get(event);\n        if (!handlers) return;\n\n        for (const handler of handlers) {\n            try {\n                await (handler as (...args: unknown[]) => Promise<void> | void)(...args);\n            } catch (error) {\n                // Log but don't stop other handlers\n                console.error(`Hook handler for \"${event}\" failed:`, error);\n            }\n        }\n    }\n\n    /**\n     * Get a plugin by name\n     */\n    get(name: string): Plugin | undefined {\n        return this.plugins.get(name)?.plugin;\n    }\n\n    /**\n     * Check if a plugin is registered\n     */\n    has(name: string): boolean {\n        return this.plugins.has(name);\n    }\n\n    /**\n     * Check if a plugin is installed\n     */\n    isInstalled(name: string): boolean {\n        return this.plugins.get(name)?.installed ?? false;\n    }\n\n    /**\n     * Get all registered plugin names\n     */\n    get names(): string[] {\n        return Array.from(this.plugins.keys());\n    }\n\n    /**\n     * Get all installed plugin names\n     */\n    get installedNames(): string[] {\n        return this.installedOrder;\n    }\n\n    /**\n     * Clear all plugins\n     */\n    clear(): void {\n        this.plugins.clear();\n        this.hooks.clear();\n        this.installedOrder = [];\n    }\n}\n\n/**\n * Global plugin registry instance\n */\nexport const globalRegistry = new PluginRegistry();\n","/**\n * Plugin System\n *\n * Extensible plugin architecture for Cloudflare Kit.\n *\n * @example\n * ```typescript\n * import { definePlugin, createApp } from 'cloudflare-kit';\n *\n * const myPlugin = definePlugin({\n *   name: 'my-plugin',\n *   version: '1.0.0',\n *   install(context) {\n *     context.logger.info('My plugin installed!');\n *   },\n *   hooks: {\n *     'request:start': (ctx) => {\n *       ctx.state.startTime = Date.now();\n *     }\n *   }\n * });\n *\n * const app = createApp({\n *   plugins: [myPlugin]\n * });\n * ```\n */\n\nexport type {\n    Plugin,\n    PluginContext,\n    PluginHooks,\n    PluginOptions,\n    PluginDefinition,\n    PluginRegistryEntry,\n    PluginMetadata,\n    App,\n    HookHandler,\n    HookResult,\n} from \"./types\";\n\nexport { PluginRegistry, globalRegistry } from \"./registry\";\n\n/**\n * Define a plugin with type safety\n */\nexport function definePlugin(plugin: {\n    name: string;\n    version: string;\n    description?: string;\n    author?: string;\n    dependencies?: string[];\n    install: (context: import(\"./types\").PluginContext) => void | Promise<void>;\n    hooks?: Partial<import(\"./types\").PluginHooks>;\n}): import(\"./types\").Plugin {\n    return plugin as import(\"./types\").Plugin;\n}\n\n/**\n * Create a plugin from a factory function\n */\nexport function createPlugin(\n    factory: (options?: Record<string, unknown>) => import(\"./types\").Plugin,\n): (options?: Record<string, unknown>) => import(\"./types\").Plugin {\n    return factory;\n}\n\n/**\n * Compose multiple plugins into one\n */\nexport function composePlugins(\n    name: string,\n    version: string,\n    ...plugins: import(\"./types\").Plugin[]\n): import(\"./types\").Plugin {\n    return definePlugin({\n        name,\n        version,\n        dependencies: plugins.flatMap((p) => p.dependencies || []),\n        async install(context) {\n            for (const plugin of plugins) {\n                await plugin.install(context);\n            }\n        },\n    });\n}\n"]}